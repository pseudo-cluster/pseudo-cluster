Описание работы программы parse_slurm_db.py.

I. Введение.
    Данная программа делает выборку за некоторый период времени [S, E]
    из статистики запуска задач на вычислительном кластере,
    управляемом системой ведения очередей Slurm. 

    Результат помещается в несколько текстовых файлов.
    Программа подсчитывает: 
    1) количество задач:
        число задач, которые стояли в очереди или выполнялись в промежутке [S, E],
        возможно, частично выходя за него.
    2) среднее время ожидания в очереди:
        обозначим за task.sumbit время постановки в очередь, task.start - время запуска задачи task.
        Тогда среднее время ожидания в очереди равно сумме
            длина пересечения [task.sumbit, task.start] с [S, E]
        по всем task, делённой на количество задач (см. пункт 1).
    3) среднюю загруженность за данный период времени:
        число процессоров, которое в среднем было использовано кластером
        за единицу времени.

        В качестве единицы времени используется 3600 секунд, т.е. 1 час.

        Иллюстрация к понятию средней загруженности:
        Пусть есть 5 задач, для каждой известно время начала и конца, а также
        кол-во испольованных процессоров.
        
        Задача          Время начала            Время конца         Кол-во процессоров

          1                 0                       57                    32
          2                 91                      217                   32
          3                 91                      198                   32
          4                 154                     209                   32
          5                 338                     398                   32

        Выделим промежутки времени, когда количество использованных процессоров не меняется:
        0..57 - 32 процессора
        57..91 - 0 процессоров
        91..154 - 64 процессора
        154..198 - 96 процессоров
        198..209 - 64 процеесора
        209..217 - 32 процессора
        217..338 - 0 процессоров
        338..398 - 32 процессора

        Обозначим за len(t1, t2) длину промежутка времени [t1, t2], делённую на длину единичного 
        промежутка времени: len(t1, t2) = (t2 - t1) / 3600.

        Тогда среднюю загруженность R на промежутке времени [0, 398]  можно посчитать следующим образом: 
        R = (32 * len(0, 57) + 0 * len(57, 91) + 64 * len(91, 154) + 96 * len(154, 198) +
            64 * len(198, 209) + 32 * len(209, 217) + 0 * len(217, 338) + 32 * len(338, 398)) 
            / 
            len(0, 398).
        
        В данном примере R примерно равно 32.5. Так получается из-за того, что есть промежутки
        времени как с высокой загруженностью (96 процессоров), так и с низкой (0 процессоров).
        

II. Входные данные.
    Программа работает с файлами формата .csv, которые были получены при помощи скрипта parse.py,
    описание запуска которого содержится в комментариях в соответствующем файле.

    Имя входого файла - result_statistics.csv (может быть изменено в строке 59).

    Файл имеет следующую структуру: 
    1) Заголовок.
        Содержит названия параметров задачи (например, идентификационный номер пользователя,
        поставившего задачу, или название вычислительного кластера). Выглядит примерно так:
        "JobID"	"UserID"	"Queue Date"	"Dispatch Time"	"Start Time"	"Completion Date"	"Size Requested"	"Status"	"Partition Allocated"	"Class"	"Time limit (seconds)"	"Cluster"	"Other"
    2) Описание задачи.
        В следующих строках содержатся описания задач, по одному на строку. В описании указаны значения
        параметров, названия которых отражены в заголовке. Пример описания:
        206384	"6807"	1385841607	1385841607	1385841607	1385841664	32	"Completed"	"LL13113023000731"	"n32_m15"	60	"bluegene"	"IONodes Per BP=N00-J00"

    В файле столбцы разделены символом табуляции, все строковые значения заключены в двойные кавычки. 
    Время выводится в формате Unix Time.

III. Запуск программы.
    Для запуска требуется python версии 2.6 или выше.
    
    Параметры запуска:
    
    1) --from S
        число, задаёт начало промежутка времени [S, E].
        Пример: --from 1345678
    2) --to E
        число, задаёт конец промежутка врмени [S, E].
        Пример: --to 999999
    3) --cluster=c
        строка, задаёт имя кластера, для которого нужно считать статистику.
        Пример: --cluster=bluegene
    4) --prefix=p
        строка, задаёт префикс имени файла, в который будет сохраняться статистика.
        Пример: --prefix=slurm_stat
        По умолчанию: slurm_stat
    5) --masquerade_users=yes\no
        yes или no. Если значение = yes, то при выводе результата значения в поле UserID будут
        заменены на значения вида 'user123'.
        Пример: --masquerade_users=no
        По умолчанию: yes

    Входные данные всегда берутся из файла result_statistics.csv (можно изменить в строке 59).

    Пример запуска:
       python parse_slurm_db.py --from 1385841607 --to 1385854253 --cluster=bluegene --masquerade-users=no 

IV. Выходные данные.
    После запуска программа создаёт два файла (здесь prefix - значение параметра --prefix,
    S - значение параметра --from, E - значение параметра --to):
    
    1) prefix_S_E_raw.csv:
        содержит описания задач, попавших в промежуток [S, E], в формате из гл. II.
    2) prefix_S_E_stat.txt:
        содержит посчитанную статистику (из гл. I) для задач из пункта 1), которая выглядит примерно так:
            Statistics for cluster bluegene from 1385841607 to 1385854253

            Total number of tasks: 123
            Average time in queue: 345.678 seconds
            Average congestion: 31415

V. Структура программы.
    В программе есть два класса:
    
    1) TaskRecord
        объект такого класса содержит описание одной задачи на кластере. 
        Имеет метод to_string, который возвращает строку описания задачи в формате 
        из гл. II.  
    2) StatisticCounter 
        класс используется для подсчёта статистики на кластере в заданном промежутке
        времени.
        Методы:
            - __init__(self, mask_users, prefix, cluster). 
                Инициализирует объект (загружает задачи из файла (фильтрует по кластеру), 
                устанавливает значения prefix и cluster).
                Параметры аналогичны параметрам запуска из гл. III.
            - calc_number_of_tasks_in_interval(self, start_time, end_time). 
                Подсчитывает количество задач в интервале [start_time, end_time].
            - calc_total_time_in_queue_in_interval(self, start_time, end_time).
                Подсчитывает общее время в очереди в промежутке [start_time, end_time], согласно
                пункту 2 гл. I.
            - calc_statistics(self, start_time, end_time).
                Главный метод. Вызывает все остальные, результаты записывает в файлы,
                согласно гл. IV.
            - calc_average_congestion(self, start_time, end_time).
                Вычисляет среднюю загруженность кластера в промежутке [start_time, end_time].
                Для этого делается следующее:
                а) выделяются задачи, которые выполнялись в промежутке [S, E]
                б) для каждой задачи task известно task.time_start, task.time_end, task.required_nodes - 
                    время начала, время конца, запрашиваемое число процессоров.
                  Назовём "событием" пару (t, x), обозначающую, что начиная с времени t на кластере работает
                  на x процессоров больше (x может быть меньше ноля).
                в) пусть имеется N полходящих задач (из п. а), тогда создаются 2 * N "событий" вида
                    (task.time_start, task.required_nodes) - в момент времени task.time_start запустилась задача,
                                                            которой нужно task.required_nodes процессоров
                    (task.time_end, -1 * task.required_nodes) - в момент времени task.time_end задача закончилась
                г) "события" сортируются по времени. При одинаковом времени сперва располагаются события, которые
                    имеют отрицательный x
                д) происходит проход по событиям в отсортированном порядке, поддерживаются переменные
                    cur_procs - текущее количество процессоров, которыми нагружен кластер
                    prev_time - граница предыдущего события
                    cur_area - текущий числитель в выражении для R (см. гл. I)
                    intervals - текущий знаменатель в выражении для R

                е) происходит пересчёт вышеуказанных переменных. Это возможно из-за того, что между
                    двумя событиями количество используемых процессоров не меняется. Поэтому
                    к cur_area прибавляется "текущая площадь" - cur_procs * длина_интервала,
                    к intervals прибавляется длина_интервала,
                    к cur_procs прибавляется количество (x) процессоров в текущем событии.
                    
    
    Работу программы контролирует функция main.
